// var x;
// x = 1;

// // 전역 변수 선언
// const x = 1;
// const y = 2;

// // 함수 정의
// function foo(a) {
//   // 지역 변수 선언
//   const x = 10;
//   const y = 20;

//   console.log("지역 변수 " + (a + x + y)); // 130
// }

// // 함수 호출
// foo(100);

// //메서드 호출
// console.log("전역변수 == " + (x + y)); // 3

// 실행 컨텍스트 스택

// const x = 1;

// function foo() {
//   const y = 2;

//   function bar() {
//     const z = 3;
//     console.log(x + y + z);
//   }
//   bar();
// }

// foo(); // 6

// 전역코드 -> 함수 코드 -> 내부 코드
// 함수가 호출되면 함수코드를 평가하여 함수 실해 컨텍스트를 생성한다.
// 이때 생성된 실행 컨텍스트는 스택 자료구조로 관리된다.
// 이를 실행 컨텍스트 스택이라고 부른다.

// 실행 컨덱스트의 생성과 식별자 검색 과정

// var x = 1;
// const y = 2;

// function foo(a) {
//   var x = 3;
//   const y = 4;

//   function bar(b) {
//     const z = 5;
//     console.log(a + b + x + y + z);
//   }
//   bar(10);
// }
// foo(20); //42

// 전역 객체 생성
// 전역 객체는 전역 코드가 평가되기 이전에 생성된다.
// Object.prototype을 상속받는다. 즉, 전역객체도 프로토타입 체인의 일원이다.

// Object.prototype.toString
// window.toString(); //[object Window]
// console.log(window.toString());

// var obj = window.__proto__.__proto__.__proto__.__proto__; //
// obj === Object.prototype; // true
// console.log(obj === Object.prototype);

/* 전역 코드 평가
소스코드가 로드 되면 자바스크립트 엔진은 전역 코드를 평가한다.

1. 전역 실행 컨텍스트 생성
2. 전역 렉시컬 호나경 생성
    2.1. 전역 환경 레코드 생성
        2.1.1. 객체 환경 레코드 생성
        2.1.2. 선언적 환경 레코드 생성
    2.2. this 바인딩
    2.3. 외부 렉시컬 환경에 대한 참조 결정
    
1. 전역 실행 컨텍스트 생성 
비어있는 전역 실행 컨텍스트를 생성하여 실행 컨테스트 스택에 푸시한다.
이때 전역 실행 컨텍스트는 실행 컨텍스트 스택의 최상위 == 실행 중인 실행 컨첵스트가 된다.

2. 전역 렉시컬 환경 생성
전역 렉시컬 환경을 생성하고 전역 실행 컨첵스트에 바인딩 한다.

2.1 전역 환경 레코드 생성 
전역 변수를 관리하는 전역 스코프, 전역 객체의 빌트인 저역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 제공한다.
var, let, const로 선언한 변수를 구분하기 위해 전역 스코프 역할을 하는 전역 환경레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다.
2.1.1. 객체 환경 레코드 생성
전역 환경 레코드를 구성하는 컴포넌트인 객체 환경 레코드는 BindingObject라고 부르는 객체와 연결된다.

전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언무으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.

// var x = 1;
// const y = 2;

// function foo(a) {
    ...
    의 전역 변수 x와 전역 함수 foo는 객체 환경 레코드를 통해 객체 환경 레코드의 BindingObject에 바인딩되어 있는 전역 객체의 프로퍼티와 메서드가 된다.
    
2.1.2. 선언적 환경 레코드 새엉
var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수 이외의 선언, 
즉, let, const 키워드로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리된다.
*/

/* 선언문 var, let, const 차이
var x;는 전역 객체인 window의 프로퍼티로 선언되는 전역 변수가 되며, 암묵적으로 undefined로 초기화됩니다. var로 선언된 변수는 호이스팅되고, 선언과 초기화가 동시에 이루어지는 특징이 있습니다.
let y;는 초기값이 없는 상태로 선언된 변수이며, undefined로 초기화됩니다. let으로 선언된 변수는 호이스팅되지만, 초기화 단계에서 undefined로 자동으로 초기화되지 않습니다.
const z;는 초기값이 할당되어야 하는 상수를 선언하는 문법이지만, const z;와 같이 초기값을 할당하지 않는 경우에는 "Missing initializer in const declaration" 에러가 발생합니다. const로 선언된 변수는 선언과 동시에 초기값을 할당해야 합니다.
var로 선언된 변수는 호이스팅이 발생합니다. 호이스팅은 변수의 선언 부분이 스코프의 맨 위로 옮겨지는 동작을 의미합니다. 따라서 변수를 선언하기 전에 참조하더라도 에러가 발생하지 않습니다. 그러나 변수의 할당은 선언 이후에 이루어져야 합니다.
let으로 선언된 변수는 블록 스코프를 따르며, 호이스팅은 발생하지만 TDZ(Temporal Dead Zone)라는 개념이 도입되어 변수 선언 이전에 접근하면 ReferenceError가 발생합니다. TDZ는 변수가 선언되기 전까지의 영역을 말하며, 해당 영역에서 변수를 사용하면 에러가 발생합니다. 따라서 let으로 선언된 변수를 선언하기 전에 사용하면 ReferenceError가 발생합니다. 

TDZ(Temporal Dead Zone, "일시적 사각 지대")는 let과 const로 선언된 변수가 선언된 위치에서 초기화되기 전까지 접근할 수 없는 영역을 말합니다.

let이나 const로 변수를 선언하면, 변수는 선언 단계와 초기화 단계로 나뉩니다. 선언 단계에서 변수는 스코프에 등록되고, 초기화 단계에서 실제로 해당 변수에 값을 할당합니다. TDZ는 이러한 초기화 단계 이전의 영역을 가리킵니다.

TDZ에서 변수를 참조하려고 하면 ReferenceError가 발생합니다. 이는 변수가 선언되었지만 초기화되기 전이기 때문에 해당 변수에 접근할 수 없는 상태입니다. 변수가 TDZ에 들어가는 시점은 변수가 선언된 위치에서부터 해당 변수가 선언된 블록의 시작까지입니다.*/

// let foo = 1; // 전역 변수

// {
//   // let, const 키워드로 선언한 변수가 호이스팅되지 않는다면 전역 변수를 참조해야한다.
//   // 하지만 let 키워드로 선언한 변수도 여친히 호이스팅이 발생하기 때문에
//   // 참조 에러(ReferenceError)가 발생한다.
//   console.log(foo); //ReferenceError: Cannot access 'foo' before initialization
//   let foo = 2;
// }

/* 
2.2 this 바인딩
전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.
일반적으로 전역 코드에서 this는 전역 객체를 가리키므로 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에는 전역 객체가 바인딩된다.
전역 코드에서 this를 참조하면 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 바인딩되어 있는 객체가 반환된다.
※ 전역 환경 레코드를 구성하는 객체 환경 레코드와 선언적 환경 레코드에는 this 바인딩이 없다.
this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다.*/

/*
2.3 외부 렉시컬 환경에 대한 참조 결정
외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경,
즉 상위 스코프를 가리킨다.  
이를 통해 스코프 체인을 구현한다.

현재 평가 중인 소스코드는 전역 코드다.
전역 코드르 포함하는 소스코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 null이 할당된다.
이말은 즉슨 전역 렉시컬 환경이 스코프 체인의 좀정에 존재함을 의미한다.

스코프 체인이란 ?
단방향 링크드 리스트
단방향 링크드 리스트(Singly Linked List)는 각 노드가 데이터와 다음 노드를 가리키는 링크(포인터)로 이루어진 선형 자료구조입니다. 각 노드는 데이터와 다음 노드를 가리키는 링크로 구성되어 있습니다.

단방향 링크드 리스트에서 각 노드는 데이터를 저장하는 역할을 하며, 다음 노드를 가리키는 링크는 다음 노드의 위치를 가리킵니다. 이 링크를 통해 리스트 내에서 순차적인 접근과 탐색이 가능합니다.

링크드 리스트의 특징은 다음과 같습니다:

순차적인 데이터 저장: 각 노드는 데이터와 다음 노드를 가리키는 링크로 구성되어 있으며, 데이터는 순차적으로 연결되어 저장됩니다.
동적 크기: 링크드 리스트는 동적으로 크기가 조절될 수 있습니다. 새로운 노드를 추가하거나 기존 노드를 삭제하여 크기를 조절할 수 있습니다.
삽입과 삭제의 효율성: 단방향 링크드 리스트는 삽입과 삭제 연산이 효율적입니다. 특정 위치에 노드를 삽입하거나 삭제할 때, 다음 노드를 바로 가리키는 링크만 조정하면 되기 때문입니다. 하지만 특정 위치에 접근하려면 처음부터 순차적으로 탐색해야 하므로 탐색 연산은 선형 시간이 소요됩니다.
무작위 접근의 어려움: 단방향 링크드 리스트는 각 노드가 다음 노드만 가리키기 때문에 무작위로 특정 위치에 접근하는 것은 어렵습니다. 특정 위치에 접근하려면 처음부터 순차적으로 탐색해야 합니다.
단방향 링크드 리스트는 데이터의 삽입과 삭제가 빈번하게 발생하고, 무작위 접근이 필요하지 않은 경우에 유용하게 사용될 수 있습니다. 하지만 데이터의 검색이나 무작위 접근이 필요한 경우에는 다른 자료구조를 고려해야 합니다.

추가적인 질문이 있으시면 언제든지 질문해주세요. 감사합니다.*/

/* 
전역 코드 실행
변수 할당문이 실행되어 전역 변수 x, y에 값이 할당된다.
그리고 foo함수가 호출된다. 
선언된 식별자를 확인하고 식별자가 있는지, 동일한 이름의 식별자가 다른 스코프에 여러 개 존재하는지 확인하여 어느 스코프의 식별자를 참조하면 되는지 결정할 필요가 있다. 이를 식별자 결정이라 한다.

식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다.

이처럼 실행 컨텍스트는 소스코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.*/

// foo 함수 코드 평가
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20); // 1)호출 직전
/* 
1) foo 함수가 호출되면 전역 코드의 실행을 일시 중단하고
foo 함수 내부로 코드의 제어권이 이동한다.
그리고 함수 코드를 평가하기 시작한다.
함수 코드 평가는 아래 순서로 진행된다.
1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
    2.1 함수 환경 레코드 생성
    2.2 this 바인딩
    2.3 외부 렉시컬 환경에 대한 참조 결정


렉시컬 스코프에서 자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다.

    */

// foo 함수 코드 실행
/* 
참조 결정이 끝나고 런타임이 시작되어 foo함수의 소스코드가 순차적으로 실행되어 
매개변수에 인수가 할당되고, 지역 변수인 x, y의 값이 할당 된다. 그리고 중첩 함수인 bar()가 실행된다. 
이때 식별자 결정을 위해 실행중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다.

그리고 bar 함수가 호출되면 bar 함수 내부로 코드의 제어권이 이동한다. 그리고 bar 함수 코드를 평가하기 시작한다. 
실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드 평가와 동일하다.

외부 환경 참조 결정이 다끝나면
consol.log(a ...+ z); 실행 된다.*/

/* 
console.log 식별자 검색
먼저 console 식별자를 스코프 체인에서 검색한다.
따라서 식별자를 검색할 때는 언제나 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색한다.
== bar 함수 실행 컨텍스트에서 검색후 console 식별자가 없으므로 
스코프 체인 상의 상위 스코프, 즉 외부 렉시컬 환경에 대한 참고가 가리키는 전역 렉시컬 환경으로 이동하여
식별자 console 식별자를 검색한다.
console 식별자는 객체 환경 레코드의 BindingObject를 통해 전역 객체에서 찾을 수 있다. 

그리고 console의 있는 log 메서드를 찾아 실행한다.
할당된 값들을 console.log메서드에 전달하여 호출한다.
*/

/* bar함수 코드 실행 종료 
bar 함수 실행 컨텍스트가 제거되었다고 해서 bar 함수 렉시컬 환경까지 즉시 소멸하는 것은 아니다.
렉시컬 환경은 실행 컨텍스트에 의해 참조되기는 하지만 독립적인 객체다.
즉, bar 함수 실행 컨텍스트가 소멸되었다고 하더라도
bar함수 렉시컬 환경을 어딘가 참조하고 있다면 bar 함수 렉시컬 환경은 소멸하지 않는다.

그뒤 foo함수 코드 실행 종료
전역 코드 실행 종료
실행컨텍스트 스택에서 팝되어 스택에는 아무것도 남아있지 않게 된다.*/
